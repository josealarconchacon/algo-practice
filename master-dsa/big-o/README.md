# Understanding Big O Notation

Explore how an algorithm's efficiency scales with an increasing number of elements.

## Key Principles

1. **Evaluate the worst-case performance using Big O notation**
2. **Combine steps sequentially (+) and multiply nested steps (*)**
3. **Assign different variables for different inputs, e.g., O(a + b)**
4. **Eliminate constants from complexity analysis**
5. **Focus on dominant terms in time complexity**

## Time Complexity

### Big O â€“ Worst Case Scenario

#### Optimal
- **O(1)**: Constant time complexity
- **O(log n)**: Logarithmic time complexity
- **O(n)**: Linear time complexity

#### Acceptable
- **O(n * log n)**: Log Linear time complexity

#### Discouraged
- **O(n^2)**: Quadratic time complexity
- **O(2^n)**: Exponential time complexity
- **O(n!)**: Factorial time complexity

- ![image](https://github.com/user-attachments/assets/928d6328-d6b5-430d-8bd2-b69b35b15907)

